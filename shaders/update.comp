#version 450 core

layout(local_size_x = 128) in;

struct Particle {
    vec2 position;
    float angle;
    float speed;
};

// SSBOs
layout(std430, binding = 0) readonly buffer InParticles {
    Particle particles[];
} inParticles;

layout(std430, binding = 1) writeonly buffer OutParticles {
    Particle particles[];
} outParticles;

// Trail Map (Read/Write)
layout(rgba8, binding = 2) uniform image2D outImage;

// Boids Grid Buffers
layout(std430, binding = 3) readonly buffer GridHeadBuffer {
    int heads[];
} gridHead;
layout(std430, binding = 4) readonly buffer ParticleNextBuffer {
    int next[];
} particleNext;

// Uniforms
uniform int   uParticleCount;
uniform float uDt;
uniform vec2  uSimSize;
uniform int   uBoundaryMode; // 0=Torus,1=Bounce,2=Klein bottle full twist

// Physarum Params
uniform int   uPhysarumEnabled;
uniform float uPhysarumIntensity;
uniform float uSensorDistance;
uniform float uSensorAngle;
uniform float uTurnAngle;
uniform float uSpeed;
uniform float uSpeedMin;
uniform float uSpeedMax;
uniform float uInertia;       // 0 = instant turn, 1 = keep velocity
uniform float uRestitution;   // collision bounce energy
uniform float uRandomWeight;

// Boids Params
uniform int   uBoidsEnabled;
uniform float uAlignmentWeight;
uniform float uSeparationWeight;
uniform float uCohesionWeight;
uniform float uBoidsRadius;
uniform float uCellSize;
uniform int   uGridWidth;
uniform int   uGridHeight;

// Collisions
uniform int   uCollisionsEnabled;
uniform float uCollisionRadius;

// Mouse Interaction
uniform vec2 uMousePos;
uniform int  uMousePressed;
uniform int  uMouseMode; // 0=Attract, 1=Repel, 2=Ring, 3=Vortex
uniform int  uMouseFalloff; // 0=1/r,1=1/r^2,2=1/r^3,3=gaussian,4=osc
uniform float uMouseStrength;
uniform float uMouseGaussianSigma;
uniform float uMouseOscFreq;
uniform int  uMouseRingOverlay;
uniform float uMouseRingRadius;

// Colors
uniform vec3 uColor1;
uniform vec3 uColor2;
uniform float uColorOffset;
uniform int   uColorSource;     // 0=angle, 1=speed (manual/auto precomputato lato CPU)
uniform float uColorSpeedMin;
uniform float uColorSpeedMax;

// Helper: RGB to HSV
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// Helper: HSV to RGB
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

const float PI = 3.14159265359;

uint hash(uint state) {
    state = state * 747796405u + 2891336453u;
    state = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (state >> 22u) ^ state;
}

float scaleToRange01(uint state) {
    return float(state) / 4294967295.0;
}

// Boundary helpers
vec2 applySensorBoundary(vec2 pos) {
    if (uBoundaryMode == 0) { // Torus
        pos = mod(pos + uSimSize, uSimSize);
    } else if (uBoundaryMode == 1) { // Bounce
        pos = clamp(pos, vec2(0.0), uSimSize - vec2(1.0));
    } else if (uBoundaryMode == 2) { // Klein bottle full twist
        if (pos.x < 0.0) {
            pos.x += uSimSize.x;
            pos.y = uSimSize.y - pos.y;
        } else if (pos.x >= uSimSize.x) {
            pos.x -= uSimSize.x;
            pos.y = uSimSize.y - pos.y;
        }
        if (pos.y < 0.0) {
            pos.y += uSimSize.y;
            pos.x = uSimSize.x - pos.x;
        } else if (pos.y >= uSimSize.y) {
            pos.y -= uSimSize.y;
            pos.x = uSimSize.x - pos.x;
        }
        pos = clamp(pos, vec2(0.0), uSimSize - vec2(1.0));
    }
    return pos;
}

vec2 topologyAwareDiff(vec2 diff) {
    if (uBoundaryMode == 0) { // Torus shortest vector
        if (diff.x > uSimSize.x * 0.5) diff.x -= uSimSize.x;
        else if (diff.x < -uSimSize.x * 0.5) diff.x += uSimSize.x;
        if (diff.y > uSimSize.y * 0.5) diff.y -= uSimSize.y;
        else if (diff.y < -uSimSize.y * 0.5) diff.y += uSimSize.y;
    } else if (uBoundaryMode == 2) { // Klein full twist: evaluate wrapped options
        vec2 best = diff;
        float bestLen = dot(best, best);

        // Wrap X with Y flip
        vec2 alt1 = vec2(diff.x + (diff.x > 0.0 ? -uSimSize.x : uSimSize.x), -diff.y);
        float l1 = dot(alt1, alt1);
        if (l1 < bestLen) { best = alt1; bestLen = l1; }

        // Wrap Y with X flip
        vec2 alt2 = vec2(-diff.x, diff.y + (diff.y > 0.0 ? -uSimSize.y : uSimSize.y));
        float l2 = dot(alt2, alt2);
        if (l2 < bestLen) { best = alt2; bestLen = l2; }

        // Wrap both with double flip
        vec2 alt3 = vec2(-diff.x + (diff.x > 0.0 ? -uSimSize.x : uSimSize.x),
                         -diff.y + (diff.y > 0.0 ? -uSimSize.y : uSimSize.y));
        float l3 = dot(alt3, alt3);
        if (l3 < bestLen) { best = alt3; }
        diff = best;
    }
    return diff;
}

vec2 vectorToTarget(vec2 from, vec2 to) {
    return topologyAwareDiff(to - from);
}

void applyBoundaryToParticle(inout Particle p, inout vec2 dir) {
    if (uBoundaryMode == 0) { // Torus
        p.position = mod(p.position + uSimSize, uSimSize);
    } else if (uBoundaryMode == 1) { // Bounce
        if (p.position.x < 0.0) {
            p.position.x = -p.position.x;
            dir.x = -dir.x;
        } else if (p.position.x >= uSimSize.x) {
            p.position.x = 2.0 * uSimSize.x - p.position.x;
            dir.x = -dir.x;
        }
        if (p.position.y < 0.0) {
            p.position.y = -p.position.y;
            dir.y = -dir.y;
        } else if (p.position.y >= uSimSize.y) {
            p.position.y = 2.0 * uSimSize.y - p.position.y;
            dir.y = -dir.y;
        }
        p.angle = atan(dir.y, dir.x);
    } else if (uBoundaryMode == 2) { // Klein bottle full twist: wrap X flips Y, wrap Y flips X
        if (p.position.x < 0.0) {
            p.position.x += uSimSize.x;
            p.position.y = uSimSize.y - p.position.y;
            dir.y = -dir.y;
        } else if (p.position.x >= uSimSize.x) {
            p.position.x -= uSimSize.x;
            p.position.y = uSimSize.y - p.position.y;
            dir.y = -dir.y;
        }
        if (p.position.y < 0.0) {
            p.position.y += uSimSize.y;
            p.position.x = uSimSize.x - p.position.x;
            dir.x = -dir.x;
        } else if (p.position.y >= uSimSize.y) {
            p.position.y -= uSimSize.y;
            p.position.x = uSimSize.x - p.position.x;
            dir.x = -dir.x;
        }
        p.angle = atan(dir.y, dir.x);
    }
}

float computeMouseFalloff(float dist) {
    float d = max(dist, 1e-3);
    if (uMouseFalloff == 0) {       // 1/r
        return 1.0 / (d + 1.0);
    } else if (uMouseFalloff == 1) { // 1/r^2
        return 1.0 / ((d + 1.0) * (d + 1.0));
    } else if (uMouseFalloff == 2) { // 1/r^3
        float t = (d + 1.0);
        return 1.0 / (t * t * t);
    } else if (uMouseFalloff == 3) { // gaussian
        float sigma = max(uMouseGaussianSigma, 1.0);
        float invTwoSigma2 = 1.0 / (2.0 * sigma * sigma);
        return exp(-d * d * invTwoSigma2);
    } else { // oscillatory
        float freq = max(uMouseOscFreq, 0.01);
        float osc = 0.5 + 0.5 * sin(d * freq);
        return osc * (1.0 / (d + 1.0));
    }
}

// Sense function
float sense(Particle p, float sensorAngleOffset) {
    float sa = p.angle + sensorAngleOffset;
    vec2 dir = vec2(cos(sa), sin(sa));
    vec2 sensorPos = p.position + dir * uSensorDistance;

    sensorPos = applySensorBoundary(sensorPos);

    ivec2 coord = ivec2(sensorPos);
    vec4 val = imageLoad(outImage, coord);
    return dot(val.rgb, vec3(0.299, 0.587, 0.114)); 
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= uint(uParticleCount)) return;

    Particle p = inParticles.particles[idx];
    vec2 prevDir = vec2(cos(p.angle), sin(p.angle));
    float desiredSpeed = uSpeed;

    // --- 1. PHYSARUM SENSING & TURNING ---
    float angleChange = 0.0;
    
    if (uPhysarumEnabled == 1) {
        uint seed = uint(idx) * 1664525u + uint(uDt * 10000.0);
        float randomSteer = scaleToRange01(hash(seed));

        float weightForward = sense(p, 0.0);
        float weightLeft    = sense(p, uSensorAngle);
        float weightRight   = sense(p, -uSensorAngle);

        float intensity = uPhysarumIntensity;
        weightForward *= intensity;
        weightLeft *= intensity;
        weightRight *= intensity;

        if (weightForward > weightLeft && weightForward > weightRight) {
            angleChange += (randomSteer - 0.5) * 0.1 * uRandomWeight;
        }
        else if (weightForward < weightLeft && weightForward < weightRight) {
            angleChange += (randomSteer - 0.5) * 2.0 * uTurnAngle;
        }
        else if (weightRight > weightLeft) {
            angleChange -= uTurnAngle * randomSteer;
        }
        else if (weightLeft > weightRight) {
            angleChange += uTurnAngle * randomSteer;
        }
        else {
            angleChange += (randomSteer - 0.5) * uRandomWeight;
        }
        
        // --- LEGACY DYNAMICS: Speed Modulation ---
        // Accelerate when sensing trail (Traffic flow behavior)
        float avgDensity = (weightForward + weightLeft + weightRight) / 3.0;
        // Elastic relaxation to base speed + Density Boost
        // The factor 0.05 controls inertia (lower = heavier particles)
        // avgDensity is usually small (0-1), uSpeed is large (10-100).
        // We boost speed by density.
        float targetSpeed = uSpeed * (1.0 + avgDensity * 2.0); 
        p.speed = mix(p.speed, targetSpeed, 0.1);
    }
    
    // --- 2. NEIGHBOR SEARCH (Boids/Collisions) ---
    vec2 alignment = vec2(0.0);
    vec2 cohesion = vec2(0.0);
    vec2 separation = vec2(0.0);
    int boidsCount = 0;

    vec2 collisionRepulse = vec2(0.0);
    int collisionCount = 0;
    float collisionOverlapAccum = 0.0;
    vec2 collisionNormal = vec2(0.0);

    if (uBoidsEnabled == 1 || uCollisionsEnabled == 1) {
        int cx = int(p.position.x / uCellSize);
        int cy = int(p.position.y / uCellSize);
        cx = clamp(cx, 0, uGridWidth - 1);
        cy = clamp(cy, 0, uGridHeight - 1);
        
        float searchRadius = max(uBoidsRadius, uCollisionRadius);
        int span = int(ceil(searchRadius / uCellSize));
        span = clamp(span, 1, 4); // bounded cost, enough coverage for large radii

        float boidsRadiusSq = uBoidsRadius * uBoidsRadius;
        float collisionRadiusSq = uCollisionRadius * uCollisionRadius;

        const int MAX_GLOBAL_CHECKS = 64;
        const int MAX_CELL_CHECKS = 8;
        int totalNeighborsChecked = 0;

        int cellsToCheck = (2 * span + 1) * (2 * span + 1);
        int budgetPerCell = MAX_GLOBAL_CHECKS / max(cellsToCheck, 1);
        budgetPerCell = clamp(budgetPerCell, 1, MAX_CELL_CHECKS);

        // Radial shells, iterated with a small random offset to remove directional bias
        for (int r = 0; r <= span && totalNeighborsChecked < MAX_GLOBAL_CHECKS; ++r) {
            int ringSize = 2 * r + 1;
            uint ringSeed = hash(uint(idx) + uint(r) * 1664525u);
            int xOffset = (ringSize > 0) ? int(ringSeed % uint(ringSize)) : 0;
            int yOffset = (ringSize > 0) ? int((ringSeed / uint(max(ringSize, 1))) % uint(ringSize)) : 0;

            for (int dyStep = 0; dyStep < ringSize && totalNeighborsChecked < MAX_GLOBAL_CHECKS; ++dyStep) {
                int dy = ((dyStep + yOffset) % ringSize) - r;
                for (int dxStep = 0; dxStep < ringSize && totalNeighborsChecked < MAX_GLOBAL_CHECKS; ++dxStep) {
                    int dx = ((dxStep + xOffset) % ringSize) - r;
                    if (abs(dx) < r && abs(dy) < r) continue; // only border for this shell

                    int nx = cx + dx;
                    int ny = cy + dy;
                    
                    bool validCell = true;
                    if (nx < 0 || nx >= uGridWidth) {
                        if (uBoundaryMode == 0) { // torus
                            if (nx < 0) nx += uGridWidth; else nx -= uGridWidth;
                        } else if (uBoundaryMode == 2) { // Klein full twist
                            if (nx < 0) {
                                nx += uGridWidth;
                                ny = uGridHeight - 1 - ny;
                            } else {
                                nx -= uGridWidth;
                                ny = uGridHeight - 1 - ny;
                            }
                        } else { // Bounce
                            validCell = false;
                        }
                    }

                    if (ny < 0 || ny >= uGridHeight) {
                        if (uBoundaryMode == 0) {
                            if (ny < 0) ny += uGridHeight; else ny -= uGridHeight;
                        } else if (uBoundaryMode == 2) { // Klein full twist
                            if (ny < 0) {
                                ny += uGridHeight;
                                nx = uGridWidth - 1 - nx;
                            } else {
                                ny -= uGridHeight;
                                nx = uGridWidth - 1 - nx;
                            }
                            if (nx < 0) nx += uGridWidth;
                            else if (nx >= uGridWidth) nx -= uGridWidth;
                        } else {
                            validCell = false;
                        }
                    }
                    if (!validCell) continue;
                    
                    int cellIndex = ny * uGridWidth + nx;
                    int neighborIdx = gridHead.heads[cellIndex];
                    
                    int checkedInCell = 0;
                    while (neighborIdx != -1 && checkedInCell < budgetPerCell && totalNeighborsChecked < MAX_GLOBAL_CHECKS) {
                        if (neighborIdx != int(idx)) {
                            Particle np = inParticles.particles[neighborIdx];
                            vec2 diff = topologyAwareDiff(np.position - p.position);
                            
                            float distSq = dot(diff, diff);
                            
                            if (uBoidsEnabled == 1 && distSq < boidsRadiusSq) {
                                alignment += vec2(cos(np.angle), sin(np.angle));
                                cohesion += diff;
                                if (distSq > 0.0001) {
                                    separation -= diff / sqrt(distSq);
                                }
                                boidsCount++;
                            }

                            if (uCollisionsEnabled == 1 && distSq < collisionRadiusSq && distSq > 0.0001) {
                                collisionRepulse -= diff / max(distSq, 1.0);
                                collisionCount++;
                                float dist = sqrt(distSq);
                                collisionOverlapAccum += max(0.0, uCollisionRadius - dist);
                            }
                            totalNeighborsChecked++;
                        }
                        neighborIdx = particleNext.next[neighborIdx];
                        checkedInCell++;
                    }
                }
            }
        }
        
        if (boidsCount > 0) {
            vec2 boidsDir = vec2(0.0);
            if (length(alignment) > 0.0) boidsDir += normalize(alignment) * uAlignmentWeight;
            if (length(cohesion) > 0.0) boidsDir += normalize(cohesion / float(boidsCount)) * uCohesionWeight;
            if (length(separation) > 0.0) boidsDir += normalize(separation / float(boidsCount)) * uSeparationWeight;
            
            // Apply boids influence to angle
            // We create a "Target Direction" and steer towards it
            if (length(boidsDir) > 0.0) {
                 float currentAngle = p.angle;
                 float targetAngle = atan(boidsDir.y, boidsDir.x);
                 
                 // Shortest angle turn
                 float da = targetAngle - currentAngle;
                 if (da > PI) da -= 2.0 * PI;
                 if (da < -PI) da += 2.0 * PI;
                 
                 // Soft steer (0.1 is steer strength)
                 angleChange += da * 0.1;
            }
        }

        if (uCollisionsEnabled == 1 && collisionCount > 0 && length(collisionRepulse) > 0.0) {
            collisionNormal = normalize(collisionRepulse / float(collisionCount));
        }
    }
    
    // Apply angle change with inertia-aware scaling
    float targetAngle = p.angle + angleChange * (1.0 - uInertia);

    // --- 3. MOUSE EFFECTS ---
    if (uMousePressed == 1) {
        vec2 toMouse = vectorToTarget(p.position, uMousePos);
        float dist = length(toMouse);
        float falloff = computeMouseFalloff(dist);
        vec2 dirToMouse = (dist > 1e-6) ? toMouse / dist : vec2(1.0, 0.0);

        vec2 baseDir = dirToMouse;
        if (uMouseMode == 1) { // Repel
            baseDir = -dirToMouse;
        } else if (uMouseMode == 2) { // Ring mode
            float ringR = max(uMouseRingRadius, 1.0);
            float sign = dist - ringR;
            baseDir = (sign >= 0.0) ? dirToMouse : -dirToMouse;
            // Stronger near ring transition
            falloff *= 1.0 + 0.5 * exp(-abs(sign) / (ringR * 0.2));
        } else if (uMouseMode == 3) { // Vortex
            baseDir = vec2(dirToMouse.y, -dirToMouse.x);
        }

        // Optional ring overlay blending with other modes
        if (uMouseRingOverlay == 1 && uMouseMode != 2) {
            float ringR = max(uMouseRingRadius, 1.0);
            float sign = dist - ringR;
            vec2 ringDir = (sign >= 0.0) ? dirToMouse : -dirToMouse;
            float ringWeight = clamp(exp(-abs(sign) / (ringR * 0.3)), 0.0, 1.0);
            baseDir = normalize(mix(baseDir, ringDir, ringWeight));
            falloff *= (1.0 + 0.5 * ringWeight);
        }

        float strength = max(uMouseStrength, 0.0);
        float speedBoost = 1.0 + strength * falloff;
        desiredSpeed = uSpeed * speedBoost;

        float desiredAngle = atan(baseDir.y, baseDir.x);
        float da = desiredAngle - targetAngle;
        da = mod(da + PI, 2.0 * PI) - PI;
        targetAngle = targetAngle + da * 0.2 * (1.0 - uInertia);
    } else {
        desiredSpeed = uSpeed;
    }

    desiredSpeed = clamp(desiredSpeed, uSpeedMin, uSpeedMax);

    // Inertia blend: keep part of previous heading
    vec2 targetDir = vec2(cos(targetAngle), sin(targetAngle));
    vec2 blendedDir = normalize(mix(prevDir, targetDir, 1.0 - uInertia));
    p.angle = atan(blendedDir.y, blendedDir.x);

    // Speed blend (energy-like conservation)
    p.speed = mix(p.speed, desiredSpeed, 1.0 - uInertia);
    p.speed = clamp(p.speed, uSpeedMin, uSpeedMax);

    // --- 4. MOVE ---
    vec2 dir = vec2(cos(p.angle), sin(p.angle));
    // Collision response: reflect and push apart
    if (collisionCount > 0 && length(collisionNormal) > 0.0) {
        dir = normalize(reflect(dir, collisionNormal));
        float avgOverlap = collisionOverlapAccum / float(max(collisionCount, 1));
        p.position += collisionNormal * avgOverlap * 0.5;
        p.speed = max(5.0, p.speed * uRestitution);
        p.angle = atan(dir.y, dir.x);
    }

    p.position += dir * p.speed * uDt;
    applyBoundaryToParticle(p, dir);

    // Write back
    outParticles.particles[idx] = p;

    // --- 5. DEPOSIT TRAIL ---
    ivec2 coord = ivec2(p.position);
    
    // New Color Logic: Adaptive
    // Base factor: angle or speed
    float colorFactor = 0.0;
    if (uColorSource == 0) {
        // Smooth wrap: 0 deg -> color1, 180 deg -> color2, 360 deg -> color1
        colorFactor = 0.5 * (1.0 - cos(p.angle));
    } else {
        float cMin = uColorSpeedMin;
        float cMax = max(uColorSpeedMax, cMin + 0.001);
        colorFactor = clamp((p.speed - cMin) / (cMax - cMin), 0.0, 1.0);
    }
    vec3 basePalette = mix(uColor1, uColor2, colorFactor);

    vec3 rgb = basePalette;
    if (uColorOffset > 0.001) {
        // "Chameleon" adaptive coloring
        // Sample what is ahead
        vec2 sensorDir = vec2(cos(p.angle), sin(p.angle));
        vec2 posF = applySensorBoundary(p.position + sensorDir * uSensorDistance);
        vec3 seenCol = imageLoad(outImage, ivec2(posF)).rgb; 
        
        if (length(seenCol) < 0.1) {
             // If dark, fallback to base palette
             rgb = basePalette;
        } else {
             // Shift Hue of seen color
             vec3 hsv = rgb2hsv(seenCol);
             hsv.x = fract(hsv.x + uColorOffset); // apply offset
             hsv.y = min(hsv.y * 1.5, 1.0);       // Boost Saturation
             hsv.z = 1.0;                         // Full brightness
             rgb = hsv2rgb(hsv);
        }
    }
    
    float depositAmount = 0.05 * uPhysarumIntensity;
    vec4 deposit = vec4(rgb, 1.0) * depositAmount;
    
    vec4 currentVal = imageLoad(outImage, coord);
    vec4 newVal = min(currentVal + deposit, vec4(1.0));
    imageStore(outImage, coord, newVal);
}
