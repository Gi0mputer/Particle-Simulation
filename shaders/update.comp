#version 450 core

layout(local_size_x = 128) in;

struct Particle {
    vec2 position;
    float angle;
    float speed;
    // Per 3D: vec3 position; vec3 direction;
};

layout(std430, binding = 0) readonly buffer InParticles { Particle particles[]; } inParticles;
layout(std430, binding = 1) writeonly buffer OutParticles { Particle particles[]; } outParticles;

layout(r32f, binding = 2) uniform image2D uTrail;

uniform int   uParticleCount;
uniform float uDt;
uniform vec2  uSimSize;
uniform float uSensorDistance;
uniform float uRandomWeight;

float rand(vec2 co){ return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453); }

void main(){
    uint idx = gl_GlobalInvocationID.x;
    if(idx >= uint(uParticleCount)) return;

    Particle p = inParticles.particles[idx];

    vec2 dir = vec2(cos(p.angle), sin(p.angle));
    p.position += dir * p.speed * uDt;

    if(p.position.x < 0.0) p.position.x += uSimSize.x;
    else if(p.position.x >= uSimSize.x) p.position.x -= uSimSize.x;
    if(p.position.y < 0.0) p.position.y += uSimSize.y;
    else if(p.position.y >= uSimSize.y) p.position.y -= uSimSize.y;

#ifdef USE_PHYSARUM_SENSORS
    vec2 forward = p.position + dir * uSensorDistance;
    vec2 leftDir = vec2(dir.y, -dir.x);
    vec2 rightDir = vec2(-dir.y, dir.x);
    float c = imageLoad(uTrail, ivec2(forward)).r;
    float l = imageLoad(uTrail, ivec2(p.position + leftDir * uSensorDistance)).r;
    float r = imageLoad(uTrail, ivec2(p.position + rightDir * uSensorDistance)).r;
    p.angle += (l - r) * 0.25;
#endif

    p.angle += (rand(p.position) - 0.5) * uRandomWeight;

    ivec2 px = ivec2(p.position);
    px = clamp(px, ivec2(0), ivec2(uSimSize) - ivec2(1));
    imageAtomicAdd(uTrail, px, 1.0);

    outParticles.particles[idx] = p;
}
