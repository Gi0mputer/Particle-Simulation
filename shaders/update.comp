#version 450 core

// If the extension for floating point atomics is available we use it,
// otherwise we emulate a float atomic add using compare-and-swap on an
// integer image. We switch the image type accordingly.
#ifdef GL_ARB_shader_image_atomic
    #extension GL_ARB_shader_image_atomic : enable
    layout(r32f, binding = 2) uniform image2D uTrail;
#else
    layout(r32ui, binding = 2) uniform uimage2D uTrail;

    void atomicAddFloat(uimage2D img, ivec2 coord, float value)
    {
        uint old = imageLoad(img, coord).r;
        while (true) {
            float oldF = uintBitsToFloat(old);
            float newF = oldF + value;
            uint  newU = floatBitsToUint(newF);
            uint  prev = imageAtomicCompSwap(img, coord, old, newU);
            if (prev == old) break; // success
            old = prev;
        }
    }
#endif

layout(local_size_x = 128) in;

struct Particle {
    vec2 position;
    float angle;
    float speed;
    // Per 3D: vec3 position; vec3 direction;
};

layout(std430, binding = 0) readonly buffer InParticles { Particle particles[]; } inParticles;
layout(std430, binding = 1) writeonly buffer OutParticles { Particle particles[]; } outParticles;



uniform int   uParticleCount;
uniform float uDt;
uniform vec2  uSimSize;
uniform float uSensorDistance;
uniform float uRandomWeight;

float rand(vec2 co){ return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453); }

void main(){
    uint idx = gl_GlobalInvocationID.x;
    if(idx >= uint(uParticleCount)) return;

    Particle p = inParticles.particles[idx];

    vec2 dir = vec2(cos(p.angle), sin(p.angle));
    p.position += dir * p.speed * uDt;

    if(p.position.x < 0.0) p.position.x += uSimSize.x;
    else if(p.position.x >= uSimSize.x) p.position.x -= uSimSize.x;
    if(p.position.y < 0.0) p.position.y += uSimSize.y;
    else if(p.position.y >= uSimSize.y) p.position.y -= uSimSize.y;

#ifdef USE_PHYSARUM_SENSORS
    vec2 forward = p.position + dir * uSensorDistance;
    vec2 leftDir = vec2(dir.y, -dir.x);
    vec2 rightDir = vec2(-dir.y, dir.x);
    #ifdef GL_ARB_shader_image_atomic
        float c = imageLoad(uTrail, ivec2(forward)).r;
        float l = imageLoad(uTrail, ivec2(p.position + leftDir * uSensorDistance)).r;
        float r = imageLoad(uTrail, ivec2(p.position + rightDir * uSensorDistance)).r;
    #else
        float c = uintBitsToFloat(imageLoad(uTrail, ivec2(forward)).r);
        float l = uintBitsToFloat(imageLoad(uTrail, ivec2(p.position + leftDir * uSensorDistance)).r);
        float r = uintBitsToFloat(imageLoad(uTrail, ivec2(p.position + rightDir * uSensorDistance)).r);
    #endif
    p.angle += (l - r) * 0.25;
#endif

    p.angle += (rand(p.position) - 0.5) * uRandomWeight;

    ivec2 px = ivec2(p.position);
    px = clamp(px, ivec2(0), ivec2(uSimSize) - ivec2(1));
#ifdef GL_ARB_shader_image_atomic
    imageAtomicAdd(uTrail, px, 1.0);
#else
    atomicAddFloat(uTrail, px, 1.0);
#endif

    outParticles.particles[idx] = p;
}
