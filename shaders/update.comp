#version 450 core

layout(local_size_x = 128) in;

// Struttura parallela a GpuParticle (CPU)
struct Particle {
    vec2 position;
    float angle;
    float speed;
};

// SSBO di input
layout(std430, binding = 0) readonly buffer InParticles {
    Particle particles[];
} inParticles;

// SSBO di output
layout(std430, binding = 1) writeonly buffer OutParticles {
    Particle particles[];
} outParticles;

// Texture RGBA8: depositiamo colore
// Notare "rgba8" e i qualificatori "readonly"/"writeonly"
layout(rgba8, binding = 2) uniform image2D outImage;

// Uniform
uniform int   uParticleCount;
uniform float uDt;
uniform vec2  uSimSize;  // dimensioni (width, height)

// Esempio parametri
uniform float uSensorDistance; // non lo useremo nel minimal
uniform float uRandomWeight;   // per noise eventuale

// Semplice rand
float rand(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= uint(uParticleCount)) return;

    // Leggiamo la particella dal SSBO in
    Particle p = inParticles.particles[idx];

    // Aggiorno la posizione con speed e angle
    vec2 dir = vec2(cos(p.angle), sin(p.angle));
    p.position += dir * p.speed * uDt;

    // Wrap-around
    if (p.position.x < 0.0)        p.position.x += uSimSize.x;
    else if (p.position.x>=uSimSize.x) p.position.x -= uSimSize.x;

    if (p.position.y < 0.0)        p.position.y += uSimSize.y;
    else if (p.position.y>=uSimSize.y) p.position.y -= uSimSize.y;

    // (Opzionale) piccola variazione di angle
    float noiseVal = (rand(p.position + vec2(idx,idx)) - 0.5) * uRandomWeight;
    p.angle += noiseVal;

    // Deposito colore (es. bianco) sulla texture in pos
    ivec2 pixelCoord = ivec2(p.position);
    // Clamping a sicurezza
    pixelCoord = clamp(pixelCoord, ivec2(0), ivec2(uSimSize)-ivec2(1,1));

    // Leggiamo, accumuliamo e scriviamo. Ad es. potremmo fare
    vec4 oldColor = imageLoad(outImage, pixelCoord);
    // Accumulo
    vec4 newColor = oldColor + vec4(0.1,0.1,0.1,1.0); // intensifichiamo canale rgb
    newColor = clamp(newColor, 0.0, 1.0);

    imageStore(outImage, pixelCoord, newColor);

    // Scriviamo la particella su outParticles
    outParticles.particles[idx] = p;
}
