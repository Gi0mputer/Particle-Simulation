#version 450 core

// The driver used for testing lacked float image atomics, so we always use an
// integer image and emulate atomicAdd on floats with compare-and-swap.
layout(r32ui, binding = 2) uniform uimage2D uTrail;

void atomicAddFloat(uimage2D img, ivec2 coord, float value)
{
    uint old = imageLoad(img, coord).r;
    while (true) {
        float oldF = uintBitsToFloat(old);
        float newF = oldF + value;
        uint  newU = floatBitsToUint(newF);
        uint  prev = imageAtomicCompSwap(img, coord, old, newU);
        if (prev == old) break; // success
        old = prev;
    }
}

layout(local_size_x = 128) in;

struct Particle {
    vec2 position;
    float angle;
    float speed;
    // Per 3D: vec3 position; vec3 direction;
};

layout(std430, binding = 0) readonly buffer InParticles { Particle particles[]; } inParticles;
layout(std430, binding = 1) writeonly buffer OutParticles { Particle particles[]; } outParticles;



uniform int   uParticleCount;
uniform float uDt;
uniform vec2  uSimSize;
uniform float uSensorDistance;
uniform float uRandomWeight;

float rand(vec2 co){ return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453); }

void main(){
    uint idx = gl_GlobalInvocationID.x;
    if(idx >= uint(uParticleCount)) return;

    Particle p = inParticles.particles[idx];

    vec2 dir = vec2(cos(p.angle), sin(p.angle));
    p.position += dir * p.speed * uDt;

    if(p.position.x < 0.0) p.position.x += uSimSize.x;
    else if(p.position.x >= uSimSize.x) p.position.x -= uSimSize.x;
    if(p.position.y < 0.0) p.position.y += uSimSize.y;
    else if(p.position.y >= uSimSize.y) p.position.y -= uSimSize.y;

#ifdef USE_PHYSARUM_SENSORS
    vec2 forward = p.position + dir * uSensorDistance;
    vec2 leftDir  = vec2(dir.y, -dir.x);
    vec2 rightDir = vec2(-dir.y, dir.x);
    float c = uintBitsToFloat(imageLoad(uTrail, ivec2(forward)).r);
    float l = uintBitsToFloat(imageLoad(uTrail, ivec2(p.position + leftDir * uSensorDistance)).r);
    float r = uintBitsToFloat(imageLoad(uTrail, ivec2(p.position + rightDir * uSensorDistance)).r);
    p.angle += (l - r) * 0.25;
#endif

    p.angle += (rand(p.position) - 0.5) * uRandomWeight;

    ivec2 px = ivec2(p.position);
    px = clamp(px, ivec2(0), ivec2(uSimSize) - ivec2(1));
    atomicAddFloat(uTrail, px, 1.0);

    outParticles.particles[idx] = p;
}
