#version 450 core

layout(local_size_x = 128) in;

struct Particle {
    vec2 position;
    float angle;
    float speed;
};

// SSBOs
layout(std430, binding = 0) readonly buffer InParticles {
    Particle particles[];
} inParticles;

layout(std430, binding = 1) writeonly buffer OutParticles {
    Particle particles[];
} outParticles;

// Trail Map (Read/Write)
layout(rgba8, binding = 2) uniform image2D outImage;

// Boids Grid Buffers
layout(std430, binding = 3) readonly buffer GridHeadBuffer {
    int heads[];
} gridHead;
layout(std430, binding = 4) readonly buffer ParticleNextBuffer {
    int next[];
} particleNext;

// Uniforms
uniform int   uParticleCount;
uniform float uDt;
uniform vec2  uSimSize;
uniform int   uBoundaryMode; // 0=Torus,1=Bounce,2=Klein X,3=Klein Y

// Physarum Params
uniform int   uPhysarumEnabled;
uniform float uPhysarumIntensity;
uniform float uSensorDistance;
uniform float uSensorAngle;
uniform float uTurnAngle;
uniform float uSpeed;
uniform float uInertia;       // 0 = instant turn, 1 = keep velocity
uniform float uRestitution;   // collision bounce energy
uniform float uRandomWeight;

// Boids Params
uniform int   uBoidsEnabled;
uniform float uAlignmentWeight;
uniform float uSeparationWeight;
uniform float uCohesionWeight;
uniform float uBoidsRadius;
uniform float uCellSize;
uniform int   uGridWidth;
uniform int   uGridHeight;

// Collisions
uniform int   uCollisionsEnabled;
uniform float uCollisionRadius;

// Mouse Interaction
uniform vec2 uMousePos;
uniform int  uMousePressed;
uniform int  uMouseMode; // 0=Attract, 1=Repel, 2=Ring, 3=Vortex

// Colors
uniform vec3 uColor1;
uniform vec3 uColor2;
uniform float uColorOffset;

// Helper: RGB to HSV
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// Helper: HSV to RGB
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

const float PI = 3.14159265359;

uint hash(uint state) {
    state = state * 747796405u + 2891336453u;
    state = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (state >> 22u) ^ state;
}

float scaleToRange01(uint state) {
    return float(state) / 4294967295.0;
}

// Boundary helpers
vec2 applySensorBoundary(vec2 pos) {
    if (uBoundaryMode == 0) { // Torus
        pos = mod(pos + uSimSize, uSimSize);
    } else if (uBoundaryMode == 1) { // Bounce
        pos = clamp(pos, vec2(0.0), uSimSize - vec2(1.0));
    } else if (uBoundaryMode == 2) { // Klein wrap on X (flip Y)
        if (pos.x < 0.0) {
            pos.x += uSimSize.x;
            pos.y = uSimSize.y - pos.y;
        } else if (pos.x >= uSimSize.x) {
            pos.x -= uSimSize.x;
            pos.y = uSimSize.y - pos.y;
        }
        pos.y = mod(pos.y + uSimSize.y, uSimSize.y);
        pos = clamp(pos, vec2(0.0), uSimSize - vec2(1.0));
    } else { // uBoundaryMode == 3, Klein wrap on Y (flip X)
        if (pos.y < 0.0) {
            pos.y += uSimSize.y;
            pos.x = uSimSize.x - pos.x;
        } else if (pos.y >= uSimSize.y) {
            pos.y -= uSimSize.y;
            pos.x = uSimSize.x - pos.x;
        }
        pos.x = mod(pos.x + uSimSize.x, uSimSize.x);
        pos = clamp(pos, vec2(0.0), uSimSize - vec2(1.0));
    }
    return pos;
}

vec2 topologyAwareDiff(vec2 diff) {
    if (uBoundaryMode == 0) { // Torus shortest vector
        if (diff.x > uSimSize.x * 0.5) diff.x -= uSimSize.x;
        else if (diff.x < -uSimSize.x * 0.5) diff.x += uSimSize.x;
        if (diff.y > uSimSize.y * 0.5) diff.y -= uSimSize.y;
        else if (diff.y < -uSimSize.y * 0.5) diff.y += uSimSize.y;
    } else if (uBoundaryMode == 2) { // Klein twist on X axis
        vec2 alt = diff;
        alt.x += (diff.x > 0.0 ? -uSimSize.x : uSimSize.x);
        alt.y = -alt.y;
        if (dot(alt, alt) < dot(diff, diff)) diff = alt;
    } else if (uBoundaryMode == 3) { // Klein twist on Y axis
        vec2 alt = diff;
        alt.y += (diff.y > 0.0 ? -uSimSize.y : uSimSize.y);
        alt.x = -alt.x;
        if (dot(alt, alt) < dot(diff, diff)) diff = alt;
    }
    return diff;
}

vec2 vectorToTarget(vec2 from, vec2 to) {
    return topologyAwareDiff(to - from);
}

void applyBoundaryToParticle(inout Particle p, inout vec2 dir) {
    if (uBoundaryMode == 0) { // Torus
        p.position = mod(p.position + uSimSize, uSimSize);
    } else if (uBoundaryMode == 1) { // Bounce
        if (p.position.x < 0.0) {
            p.position.x = -p.position.x;
            dir.x = -dir.x;
        } else if (p.position.x >= uSimSize.x) {
            p.position.x = 2.0 * uSimSize.x - p.position.x;
            dir.x = -dir.x;
        }
        if (p.position.y < 0.0) {
            p.position.y = -p.position.y;
            dir.y = -dir.y;
        } else if (p.position.y >= uSimSize.y) {
            p.position.y = 2.0 * uSimSize.y - p.position.y;
            dir.y = -dir.y;
        }
        p.angle = atan(dir.y, dir.x);
    } else if (uBoundaryMode == 2) { // Klein wrap on X (flip Y)
        if (p.position.x < 0.0) {
            p.position.x += uSimSize.x;
            p.position.y = uSimSize.y - p.position.y;
            dir.y = -dir.y;
        } else if (p.position.x >= uSimSize.x) {
            p.position.x -= uSimSize.x;
            p.position.y = uSimSize.y - p.position.y;
            dir.y = -dir.y;
        }
        if (p.position.y < 0.0) p.position.y += uSimSize.y;
        else if (p.position.y >= uSimSize.y) p.position.y -= uSimSize.y;
        p.angle = atan(dir.y, dir.x);
    } else { // uBoundaryMode == 3, Klein wrap on Y (flip X)
        if (p.position.y < 0.0) {
            p.position.y += uSimSize.y;
            p.position.x = uSimSize.x - p.position.x;
            dir.x = -dir.x;
        } else if (p.position.y >= uSimSize.y) {
            p.position.y -= uSimSize.y;
            p.position.x = uSimSize.x - p.position.x;
            dir.x = -dir.x;
        }
        if (p.position.x < 0.0) p.position.x += uSimSize.x;
        else if (p.position.x >= uSimSize.x) p.position.x -= uSimSize.x;
        p.angle = atan(dir.y, dir.x);
    }
}

// Sense function
float sense(Particle p, float sensorAngleOffset) {
    float sa = p.angle + sensorAngleOffset;
    vec2 dir = vec2(cos(sa), sin(sa));
    vec2 sensorPos = p.position + dir * uSensorDistance;

    sensorPos = applySensorBoundary(sensorPos);

    ivec2 coord = ivec2(sensorPos);
    vec4 val = imageLoad(outImage, coord);
    return dot(val.rgb, vec3(0.299, 0.587, 0.114)); 
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= uint(uParticleCount)) return;

    Particle p = inParticles.particles[idx];
    vec2 prevDir = vec2(cos(p.angle), sin(p.angle));
    float desiredSpeed = uSpeed;

    // --- 1. PHYSARUM SENSING & TURNING ---
    float angleChange = 0.0;
    
    if (uPhysarumEnabled == 1) {
        uint seed = uint(idx) * 1664525u + uint(uDt * 10000.0);
        float randomSteer = scaleToRange01(hash(seed));

        float weightForward = sense(p, 0.0);
        float weightLeft    = sense(p, uSensorAngle);
        float weightRight   = sense(p, -uSensorAngle);

        float intensity = uPhysarumIntensity;
        weightForward *= intensity;
        weightLeft *= intensity;
        weightRight *= intensity;

        if (weightForward > weightLeft && weightForward > weightRight) {
            angleChange += (randomSteer - 0.5) * 0.1 * uRandomWeight;
        }
        else if (weightForward < weightLeft && weightForward < weightRight) {
            angleChange += (randomSteer - 0.5) * 2.0 * uTurnAngle;
        }
        else if (weightRight > weightLeft) {
            angleChange -= uTurnAngle * randomSteer;
        }
        else if (weightLeft > weightRight) {
            angleChange += uTurnAngle * randomSteer;
        }
        else {
            angleChange += (randomSteer - 0.5) * uRandomWeight;
        }
        
        // --- LEGACY DYNAMICS: Speed Modulation ---
        // Accelerate when sensing trail (Traffic flow behavior)
        float avgDensity = (weightForward + weightLeft + weightRight) / 3.0;
        // Elastic relaxation to base speed + Density Boost
        // The factor 0.05 controls inertia (lower = heavier particles)
        // avgDensity is usually small (0-1), uSpeed is large (10-100).
        // We boost speed by density.
        float targetSpeed = uSpeed * (1.0 + avgDensity * 2.0); 
        p.speed = mix(p.speed, targetSpeed, 0.1);
    }
    
    // --- 2. NEIGHBOR SEARCH (Boids/Collisions) ---
    vec2 alignment = vec2(0.0);
    vec2 cohesion = vec2(0.0);
    vec2 separation = vec2(0.0);
    int boidsCount = 0;

    vec2 collisionRepulse = vec2(0.0);
    int collisionCount = 0;
    float collisionOverlapAccum = 0.0;
    vec2 collisionNormal = vec2(0.0);

    if (uBoidsEnabled == 1 || uCollisionsEnabled == 1) {
        int cx = int(p.position.x / uCellSize);
        int cy = int(p.position.y / uCellSize);
        cx = clamp(cx, 0, uGridWidth - 1);
        cy = clamp(cy, 0, uGridHeight - 1);
        
        float searchRadius = max(uBoidsRadius, uCollisionRadius);
        int span = int(ceil(searchRadius / uCellSize));
        span = clamp(span, 1, 4); // bounded cost, enough coverage for large radii

        float boidsRadiusSq = uBoidsRadius * uBoidsRadius;
        float collisionRadiusSq = uCollisionRadius * uCollisionRadius;

        const int MAX_GLOBAL_CHECKS = 64;
        const int MAX_CELL_CHECKS = 8;
        int totalNeighborsChecked = 0;

        int cellsToCheck = (2 * span + 1) * (2 * span + 1);
        int budgetPerCell = MAX_GLOBAL_CHECKS / max(cellsToCheck, 1);
        budgetPerCell = clamp(budgetPerCell, 1, MAX_CELL_CHECKS);

        // Radial shells, iterated with a small random offset to remove directional bias
        for (int r = 0; r <= span && totalNeighborsChecked < MAX_GLOBAL_CHECKS; ++r) {
            int ringSize = 2 * r + 1;
            uint ringSeed = hash(uint(idx) + uint(r) * 1664525u);
            int xOffset = (ringSize > 0) ? int(ringSeed % uint(ringSize)) : 0;
            int yOffset = (ringSize > 0) ? int((ringSeed / uint(max(ringSize, 1))) % uint(ringSize)) : 0;

            for (int dyStep = 0; dyStep < ringSize && totalNeighborsChecked < MAX_GLOBAL_CHECKS; ++dyStep) {
                int dy = ((dyStep + yOffset) % ringSize) - r;
                for (int dxStep = 0; dxStep < ringSize && totalNeighborsChecked < MAX_GLOBAL_CHECKS; ++dxStep) {
                    int dx = ((dxStep + xOffset) % ringSize) - r;
                    if (abs(dx) < r && abs(dy) < r) continue; // only border for this shell

                    int nx = cx + dx;
                    int ny = cy + dy;
                    
                    bool validCell = true;
                    if (nx < 0 || nx >= uGridWidth) {
                        if (uBoundaryMode == 0) { // torus
                            if (nx < 0) nx += uGridWidth; else nx -= uGridWidth;
                        } else if (uBoundaryMode == 2) { // Klein X twist
                            if (nx < 0) nx += uGridWidth; else nx -= uGridWidth;
                            ny = uGridHeight - 1 - ny;
                        } else if (uBoundaryMode == 3) { // Klein Y twist keeps X wrapped
                            if (nx < 0) nx += uGridWidth; else nx -= uGridWidth;
                        } else { // Bounce
                            validCell = false;
                        }
                    }

                    if (ny < 0 || ny >= uGridHeight) {
                        if (uBoundaryMode == 0) {
                            if (ny < 0) ny += uGridHeight; else ny -= uGridHeight;
                        } else if (uBoundaryMode == 2) { // X twist, Y wraps normally
                            if (ny < 0) ny += uGridHeight; else ny -= uGridHeight;
                        } else if (uBoundaryMode == 3) { // Y twist mirrors X
                            if (ny < 0) ny += uGridHeight; else ny -= uGridHeight;
                            nx = uGridWidth - 1 - nx;
                            if (nx < 0) nx += uGridWidth;
                            else if (nx >= uGridWidth) nx -= uGridWidth;
                        } else {
                            validCell = false;
                        }
                    }
                    if (!validCell) continue;
                    
                    int cellIndex = ny * uGridWidth + nx;
                    int neighborIdx = gridHead.heads[cellIndex];
                    
                    int checkedInCell = 0;
                    while (neighborIdx != -1 && checkedInCell < budgetPerCell && totalNeighborsChecked < MAX_GLOBAL_CHECKS) {
                        if (neighborIdx != int(idx)) {
                            Particle np = inParticles.particles[neighborIdx];
                            vec2 diff = topologyAwareDiff(np.position - p.position);
                            
                            float distSq = dot(diff, diff);
                            
                            if (uBoidsEnabled == 1 && distSq < boidsRadiusSq) {
                                alignment += vec2(cos(np.angle), sin(np.angle));
                                cohesion += diff;
                                if (distSq > 0.0001) {
                                    separation -= diff / sqrt(distSq);
                                }
                                boidsCount++;
                            }

                            if (uCollisionsEnabled == 1 && distSq < collisionRadiusSq && distSq > 0.0001) {
                                collisionRepulse -= diff / max(distSq, 1.0);
                                collisionCount++;
                                float dist = sqrt(distSq);
                                collisionOverlapAccum += max(0.0, uCollisionRadius - dist);
                            }
                            totalNeighborsChecked++;
                        }
                        neighborIdx = particleNext.next[neighborIdx];
                        checkedInCell++;
                    }
                }
            }
        }
        
        if (boidsCount > 0) {
            vec2 boidsDir = vec2(0.0);
            if (length(alignment) > 0.0) boidsDir += normalize(alignment) * uAlignmentWeight;
            if (length(cohesion) > 0.0) boidsDir += normalize(cohesion / float(boidsCount)) * uCohesionWeight;
            if (length(separation) > 0.0) boidsDir += normalize(separation / float(boidsCount)) * uSeparationWeight;
            
            // Apply boids influence to angle
            // We create a "Target Direction" and steer towards it
            if (length(boidsDir) > 0.0) {
                 float currentAngle = p.angle;
                 float targetAngle = atan(boidsDir.y, boidsDir.x);
                 
                 // Shortest angle turn
                 float da = targetAngle - currentAngle;
                 if (da > PI) da -= 2.0 * PI;
                 if (da < -PI) da += 2.0 * PI;
                 
                 // Soft steer (0.1 is steer strength)
                 angleChange += da * 0.1;
            }
        }

        if (uCollisionsEnabled == 1 && collisionCount > 0 && length(collisionRepulse) > 0.0) {
            collisionNormal = normalize(collisionRepulse / float(collisionCount));
        }
    }
    
    // Apply angle change with inertia-aware scaling
    float targetAngle = p.angle + angleChange * (1.0 - uInertia);

    // --- 3. MOUSE EFFECTS ---
    if (uMousePressed == 1) {
        vec2 toMouse = vectorToTarget(p.position, uMousePos);
        float dist = length(toMouse);
        float radius = 400.0;
        
        if (dist < radius && dist > 1.0) { 
            float desiredAngle = targetAngle;
            bool applySteer = true;

            if (uMouseMode == 0) { // Attract
                 desiredAngle = atan(toMouse.y, toMouse.x);
                 desiredSpeed = uSpeed * 2.0;
            } else if (uMouseMode == 1) { // Repel
                 desiredAngle = atan(-toMouse.y, -toMouse.x);
                 desiredSpeed = uSpeed * 3.0;
            } else if (uMouseMode == 2) { // Ring
                 float ringRadius = radius * 0.5;
                 if (dist > ringRadius) {
                     desiredAngle = atan(toMouse.y, toMouse.x);
                     desiredSpeed = uSpeed * 2.0;
                 } else {
                     desiredAngle = atan(-toMouse.y, -toMouse.x);
                     desiredSpeed = uSpeed * 2.5;
                 }
            } else if (uMouseMode == 3) { // Vortex
                 desiredAngle = atan(toMouse.x, -toMouse.y);
                 desiredSpeed = uSpeed * 1.5;
            } else {
                 applySteer = false;
            }
            
            if (applySteer) {
                float da = desiredAngle - targetAngle;
                da = mod(da + PI, 2.0 * PI) - PI;
                targetAngle = targetAngle + da * 0.15 * (1.0 - uInertia);
            }
        } else {
            desiredSpeed = uSpeed;
        }
    } else {
        desiredSpeed = uSpeed;
    }

    // Inertia blend: keep part of previous heading
    vec2 targetDir = vec2(cos(targetAngle), sin(targetAngle));
    vec2 blendedDir = normalize(mix(prevDir, targetDir, 1.0 - uInertia));
    p.angle = atan(blendedDir.y, blendedDir.x);

    // Speed blend (energy-like conservation)
    p.speed = mix(p.speed, desiredSpeed, 1.0 - uInertia);

    // --- 4. MOVE ---
    vec2 dir = vec2(cos(p.angle), sin(p.angle));
    // Collision response: reflect and push apart
    if (collisionCount > 0 && length(collisionNormal) > 0.0) {
        dir = normalize(reflect(dir, collisionNormal));
        float avgOverlap = collisionOverlapAccum / float(max(collisionCount, 1));
        p.position += collisionNormal * avgOverlap * 0.5;
        p.speed = max(5.0, p.speed * uRestitution);
        p.angle = atan(dir.y, dir.x);
    }

    p.position += dir * p.speed * uDt;
    applyBoundaryToParticle(p, dir);

    // Write back
    outParticles.particles[idx] = p;

    // --- 5. DEPOSIT TRAIL ---
    ivec2 coord = ivec2(p.position);
    
    // New Color Logic: Adaptive
    vec3 rgb;
    if (uColorOffset > 0.001) {
        // "Chameleon" adaptive coloring
        // Sample what is ahead
        vec2 sensorDir = vec2(cos(p.angle), sin(p.angle));
        vec2 posF = applySensorBoundary(p.position + sensorDir * uSensorDistance);
        vec3 seenCol = imageLoad(outImage, ivec2(posF)).rgb; 
        
        if (length(seenCol) < 0.1) {
             // If dark, default to standard angle-based color
             float factor = fract(p.angle / (2.0 * PI));
             rgb = mix(uColor1, uColor2, factor);
        } else {
             // Shift Hue of seen color
             vec3 hsv = rgb2hsv(seenCol);
             hsv.x = fract(hsv.x + uColorOffset); // apply offset
             hsv.y = min(hsv.y * 1.5, 1.0);       // Boost Saturation
             hsv.z = 1.0;                         // Full brightness
             rgb = hsv2rgb(hsv);
        }
    } else {
        // Standard
        float factor = fract(p.angle / (2.0 * PI));
        rgb = mix(uColor1, uColor2, factor);
    }
    
    float depositAmount = 0.05 * uPhysarumIntensity;
    vec4 deposit = vec4(rgb, 1.0) * depositAmount;
    
    vec4 currentVal = imageLoad(outImage, coord);
    vec4 newVal = min(currentVal + deposit, vec4(1.0));
    imageStore(outImage, coord, newVal);
}
